/** * Create by LDY 2019/7/3.<br> */function VCrtcSerive() {    var VCrtcSeriveSelf = this;    VCrtcSeriveSelf.apiService = "cs.lalonline.cn";    VCrtcSeriveSelf.participants = {};//参会者集合    VCrtcSeriveSelf.videoStream;//远端视频流    VCrtcSeriveSelf.audioStream;//远端音频流    VCrtcSeriveSelf.localStream;    VCrtcSeriveSelf.mcuHost; //会中mcu host    VCrtcSeriveSelf.alias; //会议号码    VCrtcSeriveSelf.pwd; //会议室密码    VCrtcSeriveSelf.conferenceId; //会见ID    VCrtcSeriveSelf.selfUUid; //监控者自己的ID    VCrtcSeriveSelf.displayName = "anonymous_bot";    VCrtcSeriveSelf.microphoneMuted;//本地麦克风是否静止    VCrtcSeriveSelf.vcrtc = new ZjRTC();    VCrtcSeriveSelf.vcrtc.clayout = "4:4";    VCrtcSeriveSelf.vcrtc.simulcast = false;//开启多流模式    VCrtcSeriveSelf.vcrtc.isShiTong = false;//是否开启专属云引擎 如果为true simulcast 必须为true；    VCrtcSeriveSelf.vcrtc.upwardLimitSimulcast = true;//上行限制多流    VCrtcSeriveSelf.isOpenFilter = false;//是否开启过滤    VCrtcSeriveSelf.isOpenInterposeByone = false;//是否开启插话 插某一个人    VCrtcSeriveSelf.isOpenInterposeByAll = false;//是否开启插所有    VCrtcSeriveSelf.isStopConference = false;//是否中断会议    VCrtcSeriveSelf.returnMsgFail = {"code": 500, "data": "fail"};    VCrtcSeriveSelf.returnMsgSuccess = {"code": 200, "data": "success"};    VCrtcSeriveSelf.uuid2Streams = [];    VCrtcSeriveSelf.setDalyTime = 3;    VCrtcSeriveSelf.updatepartcipant = function (partcipant) {        if (partcipant.uuid in VCrtcSeriveSelf.participants) {            VCrtcSeriveSelf.participants[partcipant.uuid] = partcipant;        } else {            if (partcipant.displayName.indexOf('anonymous') === -1) {                VCrtcSeriveSelf.participants[partcipant.uuid] = partcipant;            }        }    }    VCrtcSeriveSelf.parseParticipant = function (data) {        function yesToBoolean(yes) {            return yes === 'YES' ? true : false;        }        function allowToBoolean(allow) {            return allow === 'ALLOW' ? true : false;        }        let participant = {            apiUrl: data.api_url,            displayName: data.display_name || data.uri.replace('sip:', ''),            hasMedia: data.has_media,            overlayText: data.overlay_text,            role: data.is_external ? 'external' : data.role,            serviceType: data.service_type,            spotlight: data.spotlight,            startTime: data.start_time * 1000 || Date.now(),            protocol: data.protocol,            vendor: data.vendor,            uri: data.uri,            uuid: data.uuid,            isVideo: yesToBoolean(data.is_video_call),            isChair: data.role === 'chair',            isWaiting: data.service_type === 'waiting_room',            isConnected: data.service_type === 'conference' || data.service_type === 'lecture',            isConnecting: data.service_type === 'connecting',            isStreaming: data.is_streaming_conference,            isMuted: yesToBoolean(data.is_muted),            isPresenting: yesToBoolean(data.is_presenting),            isPresentationSupported: yesToBoolean(data.presentation_supported),            isFeccSupported: yesToBoolean(data.fecc_supported),            isRxPresentation: allowToBoolean(data.rx_presentation_policy),            isExternal: data.is_external,            delay_time: data.delay_time,            isEarMuted: yesToBoolean(data.ear_muted),            ishardVmute: data.v_muted > 0 ? true : false        };        if (data.is_speaking !== undefined) {            participant['vad'] = data.is_speaking === "YES" ? 100 : 0;        }        if (this.selfUUid == participant.uuid) {            participant.isSelf = true;        }        return participant;    };//    VCrtcSeriveSelf.vcrtc.onSetup = function (stream, pinStatus, conferenceExtension) {        setTimeout(function () {            if (stream) {                VCrtcSeriveSelf.localStream = stream;            }            VCrtcSeriveSelf.vcrtc.connect(this.pwd, conferenceExtension);        });    };    VCrtcSeriveSelf.vcrtc.onConnect = function (stream, uuid) {        //监控人入会以后，即可发送自己静音，并且邀请两端入会        VCrtcSeriveSelf.selfUUid = VCrtcSeriveSelf.vcrtc.uuid;        //2、监控进会以后 给自己静画取消延时        VCrtcSeriveSelf.vcrtc.setParticipantMute(VCrtcSeriveSelf.vcrtc.uuid, "mute");        VCrtcSeriveSelf.vcrtc.setParticipantVideoMute(VCrtcSeriveSelf.vcrtc.uuid, "hard_vmute");        if (VCrtcSeriveSelf.vcrtc.simulcast) {            // 多流模式，第一个流为音频流，其没有uuid。 后续流为视频流，uuid为视频流的所有者            if (!uuid) { //                VCrtcSeriveSelf.audioStream = stream            } else {                VCrtcSeriveSelf.uuid2Streams[uuid] = stream;            }        } else {            VCrtcSeriveSelf.videoStream = stream;            VCrtcSeriveSelf.audioStream = stream;        }        setTimeout(function () {            VCrtcSeriveSelf.vcrtc.setParticipantDelayPlay(VCrtcSeriveSelf.vcrtc.uuid, "cancel_delay", 1);        }, 4000);        window.postMessage({type: 'Stream', data: "new add", code: 200}, '*');    };    //多流模式下视频流更新    VCrtcSeriveSelf.vcrtc.onRemoveStream = function (uuid) {        delete VCrtcSeriveSelf.uuid2Streams[uuid];        logdebug('uuid: ', uuid, ' removed.');        window.postMessage({type: 'Stream', data: "del", code: 200}, '*');    }    VCrtcSeriveSelf.vcrtc.onUpdateStream = function (stream, uuid) {        delete VCrtcSeriveSelf.uuid2Streams[uuid];        VCrtcSeriveSelf.uuid2Streams[uuid] = stream;        logdebug('uuid: ', uuid, 'stream: ', stream, ' updated');        window.postMessage({type: 'Stream', data: "update", code: 200}, '*');    }    VCrtcSeriveSelf.vcrtc.onUpdateStream = function (stream, uuid) {        delete VCrtcSeriveSelf.uuid2Streams[uuid];        VCrtcSeriveSelf.uuid2Streams[uuid] = stream;        logdebug('uuid: ', uuid, 'stream: ', stream, ' updated');        window.postMessage({type: 'Stream', data: "update", code: 200}, '*');    }    //获取与会人列表    VCrtcSeriveSelf.vcrtc.onLayoutUpdate = function (data) {        logdebug("onLayoutUpdate", data);    };    VCrtcSeriveSelf.vcrtc.onParticipantUpdate = function (data) {        console.log('call::participantUpdate');        let updatePartcipant = VCrtcSeriveSelf.parseParticipant(data);        setTimeout(function () {            VCrtcSeriveSelf.updatepartcipant(updatePartcipant);        }, 100);    };    VCrtcSeriveSelf.vcrtc.onParticipantDelete = function (data) {        console.log('call::participantDeleted::' + data.uuid);        delete VCrtcSeriveSelf.participants[data.uuid];    };    VCrtcSeriveSelf.vcrtc.onDisconnect = function (data) {        console.log("conference is idsconnect...");        VCrtcSeriveSelf.videoStream = null;//远端视频流        VCrtcSeriveSelf.audioStream = null;//远端音频流        VCrtcSeriveSelf.participants = {};        window.postMessage({type: 'diconnect', data: data}, '*');    }    VCrtcSeriveSelf.vcrtc.onError = function (msg) {        console.log(msg);        window.postMessage({type: 'Exception', data: msg, code: 500}, '*');    }}//监控入会VCrtcSerive.prototype.enterConference = function (conferenceId) {    let _this = this;    //掉用接口查询    let request = "/meeting_room/get_meetingroom/" + conferenceId;    _this.sendRequest(request, null, function (msg) {            try {                let resData = JSON.parse(msg.currentTarget.response);                if (resData.code == 200) {                    _this.pwd = resData.data.aipKey;                    _this.mcuHost = resData.data.mcuHost;                    _this.guestPassword = resData.data.guestPassword;                    _this.alias = resData.data.meetid;                    _this.vcrtc.pin = _this.pwd;                    _this.hideme = true;                    _this.vcrtc.makeCall(_this.mcuHost, _this.alias, _this.displayName, null, 'video');                    return _this.returnMsgSuccess;                } else {                    console.debug("sendRequest resData response code is not 200");                    window.postMessage({type: 'Exception', data: "API get_meetingroom error", code: 40001}, '*');                    return _this.returnMsgFail;                }            } catch (err) {                console.error("sendRequest resData is error:" + err);                window.postMessage({type: 'Exception', data: err, code: 40001}, '*');                return _this.returnMsgFail;            }        }    );}//监控退会VCrtcSerive.prototype.exitConference = function () {    var _this = this;    try {        logdebug("##########监管人员退出监管###############");        //关闭过滤        _this.closeFilterOne();        //恢复会议室        _this.recorveConfrence();        //结束插话        _this.endChimedMio();        setTimeout(function () {            _this.vcrtc.disconnectCall();            _this.vcrtc.disconnect();        }, 500);        this.participants = {};        logdebug("##########监管人员退出监管 完成###############");        return _this.returnMsgSuccess;    } catch (error) {        return _this.returnMsgFail;    }}//开始插话VCrtcSerive.prototype.startChimedMio = function (conferenceId, alais) {    let _this = this;    // this.vcrtc.addCall("audio");    let participants = this.participants;    //当uuid不传即插话双方    //给自己取消静音    _this.vcrtc.setParticipantMute(this.selfUUid);    logdebug("0、开始插话某取消自己静音");    if (alais) {        //插话某一方的uuid        let appointUUid = _this.seachTerminalMsg(alais);        if (appointUUid == "") {            return this.returnMsgFail;        }        logdebug("1、开始插话某一方uuid:" + appointUUid + "::displayName::" + participants[appointUUid].displayName);        //分别将会见双方静画（不让别人看到）、静音（不让别人听到）。        // _this.vcrtc.setMuteAllGuests(true);        // logdebug("1、会见双方（访客）已静音");        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            //将对方闭耳            if (uuid != appointUUid) {                //让对方听不到                _this.vcrtc.setParticipantMutear(uuid, true);                logdebug("2、未被插话一方:" + participants[uuid].displayName + "::已闭音...");            } else {                _this.vcrtc.setParticipantMutear(uuid);                //插话                // this.vcrtc.overlayTextUpdate(uuid,participants[uuid].displayName+"(插话中)");                _this.updateOerlayText(participants[uuid].displayName, uuid, "(插话中)");                logdebug("3、被插话一方:" + participants[uuid].displayName + "::取消闭音...");            }            //双方禁画            // _this.vcrtc.setParticipantVideoMute(uuid, "hard_vmute");            // logdebug("4、禁画::" + participants[uuid].displayName);            //取消延时            if (participants[uuid].delay_time > 0) {                _this.vcrtc.setParticipantDelayPlay(uuid, "cancel_delay");                logdebug("4、延时会见中取消延时方::" + participants[uuid].displayName);            }            //end 会见双方 互相听不到对方声音、看不到对方画面 完成        }        logdebug("5、插话某一方成功....");        this.isOpenInterposeByone = true;        return this.returnMsgSuccess;    } else {        logdebug("1、开始插话双方......");        if (this.isOpenFilter) {            //如果开启了过滤            // _this.vcrtc.setMuteAllGuests(true);            // logdebug("1、已开启过过滤...双方（访客）静音......");        }        //插话双方        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            //插话            if (participants[uuid].delay_time > 0) {                _this.vcrtc.setParticipantDelayPlay(uuid, "cancel_delay");                logdebug("2、延时会见中取消声音延时方::" + participants[uuid].displayName);            }            if (participants[uuid].isEarMuted) {                _this.vcrtc.setParticipantMutear(uuid, false);                logdebug("3、取消闭音::" + participants[uuid].displayName);            }            // this.vcrtc.overlayTextUpdate(uuid,participants[uuid].displayName+"(插话中)");            _this.updateOerlayText(participants[uuid].displayName, uuid, "(插话中)");        }        this.isOpenInterposeByAll = true;        logdebug("4、插话双方结束......");        return this.returnMsgSuccess;    }};//结束插话VCrtcSerive.prototype.endChimedMio = function (conferenceId, alais) {    let _this = this;    let participants = this.participants;    //当uuid不传即插话双方    this.vcrtc.setParticipantMute(this.selfUUid, "mute");    logdebug("0、结束插话某开启监管静音");    _this.vcrtc.setMuteAllGuests(false);    logdebug("1、取消会见双方静音");    for (let uuid in participants) {        if (participants[uuid].isSelf || participants[uuid].isChair) {            continue;        }        //将取消闭音        if (participants[uuid].isEarMuted) {            _this.vcrtc.setParticipantMutear(uuid);            logdebug("2、取消闭音::" + participants[uuid].displayName);        }        // //取消禁画        // _this.vcrtc.setParticipantVideoMute(uuid);        // logdebug("3、取消静画::" + participants[uuid].displayName);        //恢复延时        this.vcrtc.setParticipantDelayPlay(uuid);        logdebug("4、恢复声音延时::" + participants[uuid].displayName);        // this.vcrtc.overlayTextUpdate(uuid,participants[uuid].displayName+"(会见中)");        _this.updateOerlayText(participants[uuid].displayName, uuid, "(会见中)");    }    this.isOpenInterposeByone = false;    this.isOpenInterposeByAll = false;    logdebug("5、关闭插话成功.....");    if (this.isOpenFilter) {        //如果开启了过滤        logdebug("6、插话时候已开启了过滤......现在恢复过滤");        setTimeout(function () {            _this.openFilterOne();        }, 500);    }    //判断是否开启了中断会议；开启了就恢复    // if (_this.isStopConference) {    //     logdebug("6、插话时候已开启了暂停会议室......现在恢复暂停");    //     _this.stopConfrence();    // }    return this.returnMsgSuccess;};VCrtcSerive.prototype.seachTerminalMsg = function (terminalId) {    let _this = this;    let request = "/meeting_user/terminal_uuid/" + terminalId;    let terminalUUid = "";    let msg = _this.sendRequest(request, null, false);    if (msg.code == 200) {        return msg.data;    } else {        console.debug("seachTerminalMsg by one is fail.");        return "";    }}//中断会议VCrtcSerive.prototype.stopConfrence = function () {    var _this = this;    //暂停    let participants = this.participants;    let settimeout = _this.setDalyTime;    try {        // this.vcrtc.setMuteAllGuests(true);        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            //唔住对方的眼睛            logdebug("0、捂住眼睛::" + participants[uuid].displayName);            _this.vcrtc.setParticipantUmuteye(uuid, true);            //闭音            _this.vcrtc.setParticipantMutear(uuid, "mutear");            logdebug("1、开始闭音::" + participants[uuid].displayName);            //取消延时            setTimeout(function () {                _this.vcrtc.setParticipantDelayPlay(uuid, "cancel_delay");                logdebug("2、取消声音的延时::" + participants[uuid].displayName);            }, (settimeout * 1000) + 1000);            // this.vcrtc.overlayTextUpdate(uuid,participants[uuid].displayName+"(暂停中)");            _this.updateOerlayText(participants[uuid].displayName, uuid, "(暂停中)");        }        this.isStopConference = true;        return this.returnMsgSuccess;    } catch (error) {        console.debug(error);        return this.returnMsgFail;    }};//会议恢复VCrtcSerive.prototype.recorveConfrence = function () {    var _this = this;    let participants = this.participants;    //暂停    try {        this.vcrtc.setMuteAllGuests(false);        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            //打开对方眼睛            logdebug("0、打开眼睛::" + participants[uuid].displayName);            this.vcrtc.setParticipantUmuteye(uuid);            //恢复延时            this.vcrtc.setParticipantDelayPlay(uuid);            logdebug("1、恢复声音延时::" + participants[uuid].displayName);            //关闭闭音            this.vcrtc.setParticipantMutear(uuid);            logdebug("2、关闭闭音::" + participants[uuid].displayName);            // this.vcrtc.overlayTextUpdate(uuid,participants[uuid].displayName+"(会见中)");            _this.updateOerlayText(participants[uuid].displayName, uuid, "(会见中)");        }        this.isStopConference = false;        return this.returnMsgSuccess;    } catch (error) {        console.debug(error);        return this.returnMsgFail;    }};//开启过滤VCrtcSerive.prototype.openFilterOne = function () {    let _this = this;    let participants = this.participants;    //全体访客静音    try {        logdebug("0、开启过滤.........");        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            let delayTime = participants[uuid].delay_time;            let settimeout = _this.setDalyTime;            logdebug("0、会议延时时间::" + delayTime);            if (delayTime > 5) {                settimeout = delayTime - _this.setDalyTime;            }            //闭音            setTimeout(function () {                _this.vcrtc.setParticipantMutear(uuid, "mutear");                logdebug("1、" + settimeout * 1000 + "s开始闭音::" + participants[uuid].displayName);            }, settimeout * 1000);            //取消延时            setTimeout(function () {                _this.vcrtc.setParticipantDelayPlay(uuid, "cancel_delay");                logdebug("2、取消声音的延时::" + participants[uuid].displayName);            }, (settimeout * 1000) + 1000);        }        this.isOpenFilter = true;        logdebug("3、开启过滤成功.....");        return this.returnMsgSuccess;    } catch (error) {        console.debug(error);        return this.returnMsgFail;    }}//关闭过滤VCrtcSerive.prototype.closeFilterOne = function () {    let participants = this.participants;    //全体访客取消    logdebug("0、关闭过滤.........");    try {        this.vcrtc.setMuteAllGuests(false);        for (let uuid in participants) {            if (participants[uuid].isSelf || participants[uuid].isChair) {                continue;            }            //恢复延时            this.vcrtc.setParticipantDelayPlay(uuid);            logdebug("1、恢复声音延时::" + participants[uuid].displayName);            //关闭闭音            this.vcrtc.setParticipantMutear(uuid);            logdebug("2、关闭闭音::" + participants[uuid].displayName);        }        this.isOpenFilter = false;        return this.returnMsgSuccess;    } catch (error) {        return this.returnMsgFail;    }}VCrtcSerive.prototype.updateOerlayText = function (displayName, uuid, addText) {    var self = this;    var slip = displayName.split("(");    self.vcrtc.overlayTextUpdate(uuid, slip[0] + addText);}VCrtcSerive.prototype.sendRequest = function (request, params, cb, retries) {    var self = this;    // Only do async if explicitly asked    var async = cb === false ? false : true;    var xhr = new XMLHttpRequest();    var xhrUrl = "https://" + self.apiService + request;    xhr.open("GET", xhrUrl, async);    if (cb) {        xhr.onload = cb;    }    if (retries === undefined) {        retries = 0;    }    xhr.onerror = function () {        if (++retries > 10 || cb === false) {            console.log("onerror........");        } else {            setTimeout(function () {                self.sendRequest(request, params, cb, retries);            }, retries * 500);        }    };    xhr.ontimeout = function () {        if (++retries > 10 || cb === false) {            console.log("ontimeout........");        } else {            setTimeout(function () {                self.sendRequest(request, params, cb, retries);            }, retries * 500);        }    };    if (params) {        xhr.setRequestHeader('Content-type', 'application/json');        xhr.send(JSON.stringify(params));    } else {        xhr.send();    }    if (cb === false) {        var msg = {};        try {            msg = JSON.parse(xhr.responseText);        } catch (error) {            msg.reason = xhr.status + " " + xhr.statusText;        }        msg.http_status = xhr.status;        return msg;    }};function loginfo(msg) {    let currTime = new Date();    console.info("[vcrtcService]::" + myformatter(currTime) + "::" + msg);}function logdebug(msg) {    let currTime = new Date();    console.debug("[vcrtcService]::" + myformatter(currTime) + "::" + msg);}function myformatter(date) {    var strDate = date.getFullYear() + "-";    strDate += date.getMonth() + 1 + "-";    strDate += date.getDate() + "-";    strDate += date.getHours() + ":";    strDate += date.getMinutes() + ":";    strDate += date.getSeconds();    return strDate;}